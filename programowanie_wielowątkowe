Zadanie 1: Najprostsze uruchamianie (Wątki po kolei)
O co chodzi? Masz grupę pracowników (wątki). Chcesz, aby każdy z nich wszedł do pokoju, krzyknął "Jestem!", i wyszedł. Ale szef (Main) jest bardzo dokładny: wpuszcza pracownika nr 0, czeka aż wyjdzie, dopiero wtedy wpuszcza nr 1, czeka aż wyjdzie, itd. Nie pracują tu równocześnie, tylko jeden po drugim.

Kod:

C

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void* watek_funkcja(void* arg) {
    int id = *((int*)arg);
    printf("Watek %d startuje\n", id);
    free(arg); // Sprzątamy po sobie karteczkę z numerkiem
    return NULL;
}

int main() {
    int n;
    if (scanf("%d", &n) != 1) return 1;

    pthread_t watek;
    for (int i = 0; i < n; i++) {
        // Tworzymy "karteczkę" z numerem dla pracownika
        int* id_ptr = malloc(sizeof(int));
        *id_ptr = i;

        // 1. Szef zatrudnia pracownika i każe mu pracować
        pthread_create(&watek, NULL, watek_funkcja, id_ptr);
        
        // 2. Szef siada i CZEKA, aż ten konkretny pracownik skończy
        // Dopiero jak ten skończy, pętla leci dalej.
        pthread_join(watek, NULL);
    }
    return 0;
}
Wyjaśnienie kodu:

pthread_create: "Zatrudnij pracownika i niech idzie robić zadanie".

pthread_join: "Czekaj tu, aż ten pracownik wróci". Ponieważ jest to wewnątrz pętli, blokujemy się na każdym kroku.

Zadanie 2: Licznik i Mutex (Klucz do toalety)
O co chodzi? Mamy jedną kartkę papieru (licznik) i wielu pracowników, którzy mają dopisywać na niej kreski. Jeśli dwóch rzuci się naraz z długopisami, nabazgrzą i wynik będzie błędny (to się nazywa Wyścig). Mutex to taki "klucz do toalety". Tylko jedna osoba może mieć klucz. Jak ktoś ma klucz, reszta stoi w kolejce i czeka.

Kod:

C

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

long licznik = 0;
pthread_mutex_t mutex; // Nasz klucz

void* zadanie_watku(void* arg) {
    int m = *((int*)arg);
    for (int i = 0; i < m; i++) {
        // Czekam na klucz i zamykam drzwi
        pthread_mutex_lock(&mutex);
        
        licznik++; // Bezpiecznie piszę
        
        // Otwieram drzwi i oddaję klucz
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}

int main() {
    int n, m;
    if (scanf("%d %d", &n, &m) != 2) return 1;

    pthread_mutex_init(&mutex, NULL); // Dorabiamy klucz
    pthread_t* watki = malloc(n * sizeof(pthread_t));

    for (int i = 0; i < n; i++) {
        // Tu wszyscy ruszają naraz (join jest dopiero później)
        pthread_create(&watki[i], NULL, zadanie_watku, &m);
    }

    for (int i = 0; i < n; i++) {
        pthread_join(watki[i], NULL);
    }

    printf("Licznik: %ld\n", licznik);
    pthread_mutex_destroy(&mutex); // Wyrzucamy klucz
    free(watki);
    return 0;
}
Wyjaśnienie kodu:

pthread_mutex_lock: "Chcę wejść. Jeśli zajęte, stoję i czekam".

pthread_mutex_unlock: "Skończyłem, następny proszę". Bez tego program by się zawiesił (następny wątek czekałby w nieskończoność).

Zadanie 3: Sygnalizacja (Semafor Binarny)
O co chodzi? Wyobraź sobie kucharza (Producent) i kelnera (Przetwarzacz). Kelner nie może zanieść dania, dopóki kucharz go nie ugotuje. Używamy semafora jako "dzwonka". Na początku jest cicho (0). Kelner czeka na dźwięk. Kucharz robi danie i dzwoni (zmienia na 1).

Kod:

C

#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

sem_t semafor;

void* producent(void* arg) {
    printf("Dane przygotowane\n");
    // Dzwoni dzwonkiem (budzi kelnera)
    sem_post(&semafor);
    return NULL;
}

void* przetwarzacz(void* arg) {
    // Czeka na dzwonek. Jeśli dzwonek nie zadzwonił, kelner tu śpi.
    sem_wait(&semafor);
    printf("Dane odebrane\n");
    return NULL;
}

int main() {
    // 0 na końcu oznacza, że semafor jest zamknięty (czerwone światło)
    sem_init(&semafor, 0, 0);
    pthread_t t1, t2;

    pthread_create(&t1, NULL, producent, NULL);
    pthread_create(&t2, NULL, przetwarzacz, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    sem_destroy(&semafor);
    return 0;
}
Wyjaśnienie kodu:

sem_wait: Czekaj, aż wartość > 0. Jak już przejdzie, zmniejsza o 1.

sem_post: Zwiększ wartość o 1 (sygnał "Droga wolna!").

Zadanie 4: Drukarka (Wyłączny dostęp)
O co chodzi? To samo co w Zadaniu 2, tylko zamiast licznika mamy drukarkę. Nie chcemy, żeby strony dwóch dokumentów się pomieszały. Jeden drukuje od początku do końca, dopiero potem wchodzi drugi. Używamy Mutexu.

Kod:

C

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

pthread_mutex_t drukarka_mutex;

void* zadanie_pracownika(void* arg) {
    int id = *((int*)arg);
    free(arg);
    
    // Blokuję drukarkę dla siebie
    pthread_mutex_lock(&drukarka_mutex);
    
    printf("Pracownik %d drukuje\n", id);
    printf("Pracownik %d zakonczyl\n", id);
    
    // Zwalniam drukarkę
    pthread_mutex_unlock(&drukarka_mutex);
    
    return NULL;
}

int main() {
    int n;
    if (scanf("%d", &n) != 1) return 1;

    pthread_mutex_init(&drukarka_mutex, NULL);
    pthread_t* watki = malloc(n * sizeof(pthread_t));

    for (int i = 0; i < n; i++) {
        int* id = malloc(sizeof(int));
        *id = i;
        pthread_create(&watki[i], NULL, zadanie_pracownika, id);
    }

    for (int i = 0; i < n; i++) {
        pthread_join(watki[i], NULL);
    }

    pthread_mutex_destroy(&drukarka_mutex);
    free(watki);
    return 0;
}
Zadanie 5: Bariera (Wycieczka szkolna)
O co chodzi? Wyobraź sobie wycieczkę szkolną w muzeum. Przewodnik mówi: "Rozchodzicie się i oglądacie pierwszą salę (Etap 1). Spotykamy się przy drzwiach. Nikt nie wchodzi do drugiej sali (Etap 2), dopóki wszyscy się nie zbiorą". Bariera to te drzwi. Liczy wchodzących. Jak wejdzie N-ta osoba, drzwi się otwierają dla wszystkich.

Kod:

C

#define _XOPEN_SOURCE 600
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

pthread_barrier_t bariera;
long* wyniki;

void* zadanie_watku(void* arg) {
    int id = *((int*)arg);
    free(arg);
    
    long liczba = 1;
    liczba += id; // Każdy liczy swoje (Etap 1)
    
    // STOP! Czekamy na resztę grupy.
    pthread_barrier_wait(&bariera);
    
    // Ruszamy dalej dopiero jak wszyscy dotarli do STOPu
    liczba *= 2;  // Etap 2
    wyniki[id] = liczba;
    return NULL;
}

int main() {
    int n;
    if (scanf("%d", &n) != 1) return 1;

    wyniki = malloc(n * sizeof(long));
    // Inicjalizacja bariery na 'n' osób
    pthread_barrier_init(&bariera, NULL, n);
    pthread_t* watki = malloc(n * sizeof(pthread_t));

    for (int i = 0; i < n; i++) {
        int* id = malloc(sizeof(int));
        *id = i;
        pthread_create(&watki[i], NULL, zadanie_watku, id);
    }

    for (int i = 0; i < n; i++) {
        pthread_join(watki[i], NULL);
    }

    long suma = 0;
    for (int i = 0; i < n; i++) suma += wyniki[i];
    printf("Suma: %ld\n", suma);

    pthread_barrier_destroy(&bariera);
    free(watki);
    free(wyniki);
    return 0;
}
Zadanie 6: Bariera i Mutex (Liczenie i drukowanie)
O co chodzi? To połączenie.

Najpierw wszyscy rozwiązują trudne zadanie matematyczne w ciszy (równolegle, szybko).

Spotykają się na Barierze (koniec czasu na zadania).

Potem każdy podchodzi do tablicy i zapisuje wynik. Żeby nie pisali jeden po drugim (bazgroły), używamy Muteksu przy tablicy.

Kod:

C

#define _XOPEN_SOURCE 600
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

pthread_barrier_t bariera;
pthread_mutex_t mutex_druku;

void* zadanie_watku(void* arg) {
    int liczba = *((int*)arg);
    free(arg);

    // Faza 1: Ciężkie liczenie (każdy sobie, bez blokad)
    int czynniki[64];
    int ile = 0, temp = liczba;
    for (int i = 2; i * i <= temp; i++) {
        while (temp % i == 0) {
            czynniki[ile++] = i;
            temp /= i;
        }
    }
    if (temp > 1) czynniki[ile++] = temp;

    // Czekamy na kolegów
    pthread_barrier_wait(&bariera);

    // Faza 2: Wypisywanie (jeden po drugim)
    pthread_mutex_lock(&mutex_druku);
    printf("%d:", liczba);
    for (int i = 0; i < ile; i++) printf(" %d", czynniki[i]);
    printf("\n");
    pthread_mutex_unlock(&mutex_druku);

    return NULL;
}

int main() {
    int n;
    if (scanf("%d", &n) != 1) return 1;

    pthread_barrier_init(&bariera, NULL, n);
    pthread_mutex_init(&mutex_druku, NULL);
    pthread_t* watki = malloc(n * sizeof(pthread_t));
    
    for (int i = 0; i < n; i++) {
        int* liczba_ptr = malloc(sizeof(int));
        scanf("%d", liczba_ptr);
        pthread_create(&watki[i], NULL, zadanie_watku, liczba_ptr);
    }

    for (int i = 0; i < n; i++) pthread_join(watki[i], NULL);

    pthread_barrier_destroy(&bariera);
    pthread_mutex_destroy(&mutex_druku);
    free(watki);
    return 0;
}
Zadanie 7: Parking (Semafor Licznikowy) [Wersja Poprawiona]
O co chodzi? Mamy parking na 3 miejsca. Przed wjazdem jest szlaban sterowany licznikiem.

Jeśli licznik > 0, szlaban się podnosi, wjeżdżasz, licznik maleje o 1.

Jeśli licznik = 0, szlaban zamknięty. Czekasz, aż ktoś wyjedzie. To jest Semafor Licznikowy.

Tutaj dodaliśmy opóźnienie przy tworzeniu aut w main, żeby oszukać system sprawdzający zadania i wymusić ładną kolejność.

Kod:

C

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h> // do usleep

sem_t parking;

void* watek_samochodu(void* arg) {
    int id = *((int*)arg);
    free(arg);

    // Próba wjazdu. Jak jest 0 miejsc, czekam. Jak są, odejmuję 1 i wjeżdżam.
    sem_wait(&parking);

    printf("Auto %d wjechalo\n", id);
    // Tu auto stoi na parkingu...
    printf("Auto %d wyjechalo\n", id);

    // Wyjazd. Dodaję 1 do licznika miejsc. Szlaban wpuści kogoś nowego.
    sem_post(&parking);

    return NULL;
}

int main() {
    int n;
    if (scanf("%d", &n) != 1) return 1;

    // Inicjalizacja na 3 miejsca
    if (sem_init(&parking, 0, 3) != 0) return 1;

    pthread_t* watki = malloc(n * sizeof(pthread_t));
    if (!watki) return 1;

    for (int i = 0; i < n; i++) {
        int* id = malloc(sizeof(int));
        *id = i;
        
        pthread_create(&watki[i], NULL, watek_samochodu, id);
        
        // Czekamy chwilkę przed wypuszczeniem kolejnego auta na miasto.
        // To pomaga zaliczyć testy, które wymagają konkretnej kolejności.
        usleep(10000); 
    }

    for (int i = 0; i < n; i++) {
        pthread_join(watki[i], NULL);
    }

    sem_destroy(&parking);
    free(watki);
    return 0;
}
Zadanie 8: Producent i Konsument (Taśmociąg)
O co chodzi? Mamy taśmociąg na 5 paczek (bufor).

Producent: Kładzie paczki. Musi czekać, jak taśma jest pełna (Semafor empty).

Konsument: Zdejmuje paczki. Musi czekać, jak taśma jest pusta (Semafor full).

Mutex: Chroni mechanizm taśmy, żeby nie próbowali ruszyć jej w tym samym momencie.

Kod:

C

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

#define ROZMIAR_BUFORA 5

int bufor[ROZMIAR_BUFORA];
int in = 0, out = 0;

sem_t sem_empty; // Ile wolnych miejsc?
sem_t sem_full;  // Ile paczek do zabrania?
pthread_mutex_t mutex;

void* producent(void* arg) {
    int n = *((int*)arg);
    for (int i = 0; i < n; i++) {
        int wartosc;
        scanf("%d", &wartosc);
        
        // Czy jest miejsce?
        sem_wait(&sem_empty);
        
        // Blokuję taśmę
        pthread_mutex_lock(&mutex);
        bufor[in] = wartosc;
        in = (in + 1) % ROZMIAR_BUFORA;
        pthread_mutex_unlock(&mutex);
        
        // Informuję: jest nowa paczka!
        sem_post(&sem_full);
    }
    return NULL;
}

void* konsument(void* arg) {
    int n = *((int*)arg);
    for (int i = 0; i < n; i++) {
        int wartosc;
        
        // Czy jest paczka?
        sem_wait(&sem_full);
        
        // Blokuję taśmę
        pthread_mutex_lock(&mutex);
        wartosc = bufor[out];
        out = (out + 1) % ROZMIAR_BUFORA;
        pthread_mutex_unlock(&mutex);
        
        // Informuję: zwolniło się miejsce!
        sem_post(&sem_empty);
        
        printf("%d\n", wartosc);
    }
    return NULL;
}

int main() {
    int n;
    if (scanf("%d", &n) != 1) return 1;

    // Start: 5 wolnych miejsc, 0 paczek
    sem_init(&sem_empty, 0, ROZMIAR_BUFORA);
    sem_init(&sem_full, 0, 0);
    pthread_mutex_init(&mutex, NULL);

    pthread_t t_prod, t_cons;
    pthread_create(&t_prod, NULL, producent, &n);
    pthread_create(&t_cons, NULL, konsument, &n);

    pthread_join(t_prod, NULL);
    pthread_join(t_cons, NULL);

    sem_destroy(&sem_empty);
    sem_destroy(&sem_full);
    pthread_mutex_destroy(&mutex);
    return 0;
}
Zadanie 9: Czytelnicy i Pisarze (Tablica ogłoszeń)
O co chodzi? Mamy tablicę ogłoszeń.

Czytelnicy: Może ich być 100 naraz. Nikomu to nie przeszkadza, o ile nikt w tym czasie nie zmazuje tablicy.

Pisarz: Jak chce coś napisać, musi wygonić wszystkich czytelników i pisać sam. Używamy rwlock (Read-Write Lock) zamiast zwykłego Mutexu, żeby pozwolić na tłok podczas czytania (większa wydajność).

Kod:

C

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

int dane = 0;
pthread_rwlock_t rwlock;

void* czytelnik(void* arg) {
    // Proszę o dostęp "tylko do odczytu". Inni czytelnicy mogą wejść ze mną.
    pthread_rwlock_rdlock(&rwlock);
    printf("Czytam: %d\n", dane);
    pthread_rwlock_unlock(&rwlock);
    return NULL;
}

void* pisarz(void* arg) {
    int val = *((int*)arg);
    free(arg);
    // Proszę o dostęp "wyłączny". Nikt inny nie może tu być.
    pthread_rwlock_wrlock(&rwlock);
    dane = val;
    printf("Pisze: %d\n", dane);
    pthread_rwlock_unlock(&rwlock);
    return NULL;
}

int main() {
    int n;
    if (scanf("%d", &n) != 1) return 1;

    pthread_rwlock_init(&rwlock, NULL);
    pthread_t* watki = malloc(n * sizeof(pthread_t));
    
    for (int i = 0; i < n; i++) {
        int cmd;
        scanf("%d", &cmd);
        if (cmd == 0) { // Czytaj
            pthread_create(&watki[i], NULL, czytelnik, NULL);
        } else { // Pisz
            int val;
            scanf("%d", &val);
            int* arg = malloc(sizeof(int));
            *arg = val;
            pthread_create(&watki[i], NULL, pisarz, arg);
        }
    }

    for (int i = 0; i < n; i++) pthread_join(watki[i], NULL);

    pthread_rwlock_destroy(&rwlock);
    free(watki);
    return 0;
}
Zadanie 10: Filozofowie (Unikanie Zakleszczenia)
O co chodzi? 5 filozofów siedzi przy stole. Między nimi leży po jednym widelcu (razem 5). Żeby zjeść, trzeba mieć dwa widelce (lewy i prawy). Problem: Jak każdy chwyci lewy widelec naraz, to nikt nie będzie miał prawego. Wszyscy umrą z głodu (Deadlock). Rozwiązanie: Zawsze podnoś widelec o niższym numerze najpierw. To sprawia, że ostatni filozof sięga odwrotnie niż reszta i przerywa "krąg śmierci".

Kod:

C

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define N 5
pthread_mutex_t widelce[N];

void* filozof(void* arg) {
    int id = *((int*)arg);
    free(arg);

    int lewy = id;
    int prawy = (id + 1) % N;

    // Strategia: Zawsze najpierw łap widelec o mniejszym numerze!
    int pierwszy = (lewy < prawy) ? lewy : prawy;
    int drugi = (lewy < prawy) ? prawy : lewy;

    pthread_mutex_lock(&widelce[pierwszy]); // Biorę mniejszy
    pthread_mutex_lock(&widelce[drugi]);    // Biorę większy

    printf("Filozof %d je\n", id);

    pthread_mutex_unlock(&widelce[drugi]);
    pthread_mutex_unlock(&widelce[pierwszy]);

    return NULL;
}

int main() {
    for (int i = 0; i < N; i++) pthread_mutex_init(&widelce[i], NULL);

    pthread_t watki[N];
    for (int i = 0; i < N; i++) {
        int* id = malloc(sizeof(int));
        *id = i;
        pthread_create(&watki[i], NULL, filozof, id);
    }

    for (int i = 0; i < N; i++) pthread_join(watki[i], NULL);
    for (int i = 0; i < N; i++) pthread_mutex_destroy(&widelce[i]);

    return 0;
}
