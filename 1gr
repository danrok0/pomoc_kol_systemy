zad. 1

​Cel: Napisać skrypt, który uruchamia zadanie w tle, czeka na nie, ale potrafi też obsłużyć przerwanie (Ctrl+C) i posprzątać po sobie.

#!/bin/bash

if [ -z "$1" ]; then
    echo "Użycie: $0 <czas_w_sekundach>"
    exit 1
fi

TIME=$1

handle_sigint() {
    echo ""
    echo "Przerwano (SIGINT). Zabijam proces potomny..."
    if kill -0 $PID 2>/dev/null; then
        kill -9 $PID
    fi
    exit 1
}

trap 'handle_sigint' SIGINT

echo "Uruchamiam zadanie na $TIME sekund..."
sleep $TIME &
PID=$!

wait $PID
echo "Zadanie zakończone."
exit 0


zad. 2

Cel: Utworzenie N procesów potomnych w strukturze płaskiej (wachlarz), gdzie jeden rodzic ma wiele dzieci (a nie dziecko ma dziecko). Każde dziecko ma unikalny status wyjścia.


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Podaj liczbę procesów jako argument.\n");
        return 1;
    }

    int n = atoi(argv[1]);
    pid_t pid;

    for (int i = 0; i < n; i++) {
        pid = fork();

        if (pid < 0) {
            perror("Fork failed");
            exit(1);
        }

        if (pid == 0) {
            printf("Dziecko %d (PID: %d) uruchomione.\n", i, getpid());
            exit(10 + i);
        }
    }

    int status;
    pid_t child_pid;

    for (int i = 0; i < n; i++) {
        child_pid = wait(&status);
        if (child_pid > 0) {
            if (WIFEXITED(status)) {
                printf("Dziecko PID %d zakończyło się kodem: %d\n", child_pid, WEXITSTATUS(status));
            }
        }
    }

    return 0;
}



zad 3 


Cel: Synchronizacja zapisu do pliku (Rodzic -> Dziecko -> Rodzic) bez użycia mutexów, wykorzystując jedynie funkcję wait() (fakt pokrewieństwa).



#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    FILE *fp = fopen("wynik.txt", "w");
    if (fp == NULL) return 1;

    fprintf(fp, "START: Proces nadrzędny inicjuje plik.\n");
    fflush(fp);

    pid_t pid = fork();

    if (pid == 0) {
        fprintf(fp, "SRODEK: Proces podrzędny dopisuje dane.\n");
        fflush(fp);
        exit(0);
    } else {
        wait(NULL);
        fprintf(fp, "KONIEC: Proces nadrzędny zamyka sekwencję.\n");
        fclose(fp);
    }

    printf("Zawartość pliku wynik.txt:\n");
    system("cat wynik.txt");

    return 0;
}

