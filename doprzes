tutaj treść:
















tutaj wklej rozwiązania i wiesz jak
zad.1

#!/bin/bash

FIFO_NAME="system_log.fifo"

# Funkcja sprzątająca (SIGINT/EXIT)
cleanup() {
    echo ""
    echo "[SYSTEM] Sprzątanie..."
    if [ -n "$READER_PID" ]; then
        kill "$READER_PID" 2>/dev/null
    fi
    if [ -e "$FIFO_NAME" ]; then
        rm "$FIFO_NAME"
        echo "[SYSTEM] Usunięto $FIFO_NAME"
    fi
    exit 0
}

trap cleanup SIGINT EXIT

# 1. Tworzenie potoku nazwanego
if [ ! -p "$FIFO_NAME" ]; then
    mkfifo "$FIFO_NAME"
    echo "[SYSTEM] Utworzono potok $FIFO_NAME"
fi

# 2. Serwer w tle (czyta z potoku)
(tail -f "$FIFO_NAME" | while read line; do
    echo "[LOG]: $line"
done) &

READER_PID=$!
echo "[SYSTEM] Serwer logów uruchomiony (PID: $READER_PID)"
sleep 1

# 3. Generowanie zdarzeń
echo "[SYSTEM] Generowanie zdarzeń..."

echo "Start systemu" > "$FIFO_NAME"
sleep 1
echo "Użytkownik zalogowany" > "$FIFO_NAME"
sleep 1
echo "Błąd krytyczny: brak kawy" > "$FIFO_NAME"
sleep 1

echo "[SYSTEM] Zakończono."

zad.2


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <string.h>
#include <sys/wait.h>

#define FIFO_NAME "mkfifo"
#define BUF_SIZE 64

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Użycie: %s <liczba_procesow_N>\n", argv[0]);
        return 1;
    }

    int N = atoi(argv[1]);
    
    // Tworzenie potoku
    if (mkfifo(FIFO_NAME, 0666) == -1) {
        // Ignoruj błąd istnienia pliku
    }

    printf("--- Uruchamiam %d procesów potomnych ---\n", N);

    for (int i = 0; i < N; i++) {
        pid_t pid = fork();

        if (pid == 0) {
            // Potomek
            srand(time(NULL) ^ (getpid() << 16));
            int wylosowana = rand() % 100;
            
            char bufor[BUF_SIZE];
            memset(bufor, 0, BUF_SIZE);
            sprintf(bufor, "%d %d", getpid(), wylosowana);

            int fd = open(FIFO_NAME, O_WRONLY);
            if (fd != -1) {
                write(fd, bufor, BUF_SIZE);
                close(fd);
            }
            exit(0);
        }
    }

    // Rodzic (Kolektor)
    int fd = open(FIFO_NAME, O_RDONLY);
    if (fd == -1) {
        perror("Błąd otwarcia potoku");
        return 1;
    }

    int suma = 0;
    char bufor_odczytu[BUF_SIZE];
    int pid_child, liczba;

    printf("--- Odbieranie danych ---\n");
    
    for (int i = 0; i < N; i++) {
        if (read(fd, bufor_odczytu, BUF_SIZE) > 0) {
            sscanf(bufor_odczytu, "%d %d", &pid_child, &liczba);
            printf("[Kolektor] Odebrano od PID %d: %d\n", pid_child, liczba);
            suma += liczba;
        }
    }

    close(fd);
    for(int i=0; i<N; i++) wait(NULL);

    printf("--- Wynik ---\n");
    printf("Suma: %d\n", suma);
    
    unlink(FIFO_NAME);
    return 0;
}

zad.3
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/wait.h>

#define FIFO_A "fifo_A"
#define FIFO_B "fifo_B"

int main() {
    mkfifo(FIFO_A, 0666);
    mkfifo(FIFO_B, 0666);

    pid_t pid = fork();

    if (pid == 0) {
        // --- DZIECKO ---
        // Otwieramy A do odczytu (paruje się z zapisem Rodzica)
        int fd_a = open(FIFO_A, O_RDONLY);
        int fd_b = open(FIFO_B, O_WRONLY);

        char buffer[100];
        read(fd_a, buffer, sizeof(buffer));
        printf("[Dziecko] Odebrano: %s\n", buffer);

        char response[] = "PONG";
        printf("[Dziecko] Wysyłam: %s\n", response);
        write(fd_b, response, strlen(response) + 1);

        close(fd_a);
        close(fd_b);
        exit(0);
    } else {
        // --- RODZIC ---
        // Otwieramy A do zapisu (czeka aż dziecko otworzy odczyt)
        int fd_a = open(FIFO_A, O_WRONLY);
        int fd_b = open(FIFO_B, O_RDONLY);

        char msg[] = "PING";
        printf("[Rodzic] Wysyłam: %s\n", msg);
        write(fd_a, msg, strlen(msg) + 1);

        char buffer[100];
        read(fd_b, buffer, sizeof(buffer));
        printf("[Rodzic] Odebrano: %s\n", buffer);

        close(fd_a);
        close(fd_b);
        wait(NULL);

        unlink(FIFO_A);
        unlink(FIFO_B);
        printf("[Rodzic] Koniec.\n");
    }

    return 0;
}
