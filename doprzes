#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <string.h>
#include <sys/wait.h>
#include <errno.h>

#define FIFO_NAME "mkfifo"
#define BUF_SIZE 64 // Stały rozmiar paczki danych

int main(int argc, char *argv[]) {
    // Sprawdzenie argumentów
    if (argc != 2) {
        printf("Użycie: %s <liczba_procesow_N>\n", argv[0]);
        return 1;
    }

    int N = atoi(argv[1]);

    // 1. Usunięcie starego potoku (dla bezpieczeństwa)
    unlink(FIFO_NAME);

    // 2. Tworzenie nowego potoku
    if (mkfifo(FIFO_NAME, 0666) == -1) {
        perror("Błąd tworzenia mkfifo");
        return 1;
    }

    printf("--- Start: %d procesów potomnych ---\n", N);

    // 3. Tworzenie dzieci
    for (int i = 0; i < N; i++) {
        pid_t pid = fork();

        if (pid < 0) {
            perror("Błąd fork");
            exit(1);
        }

        if (pid == 0) {
            // --- KOD DZIECKA ---
            srand(time(NULL) ^ (getpid() << 16));
            int wylosowana = rand() % 100;
            
            // Przygotowanie bufora - WAŻNE: wypełniamy zerami, żeby mieć stały rozmiar
            char bufor[BUF_SIZE];
            memset(bufor, 0, BUF_SIZE); 
            // Wpisujemy dane do bufora
            sprintf(bufor, "%d %d", getpid(), wylosowana);

            // Otwieramy potok. W razie błędu wypisujemy komunikat i kończymy z błędem!
            int fd = open(FIFO_NAME, O_WRONLY);
            if (fd == -1) {
                fprintf(stderr, "[Dziecko %d] Błąd otwarcia potoku! %s\n", getpid(), strerror(errno));
                exit(1); 
            }

            // Wysyłamy ZAWSZE pełne 64 bajty
            if (write(fd, bufor, BUF_SIZE) == -1) {
                perror("[Dziecko] Błąd zapisu");
                close(fd);
                exit(1);
            }

            // Sukces
            close(fd);
            exit(0);
        }
    }

    // --- KOD RODZICA ---
    
    // Rodzic otwiera potok
    int fd = open(FIFO_NAME, O_RDONLY);
    if (fd == -1) {
        perror("[Rodzic] Błąd otwarcia potoku");
        unlink(FIFO_NAME);
        return 1;
    }

    int suma = 0;
    char bufor_odczytu[BUF_SIZE];
    int pid_child, liczba;
    int odebrane_pakiety = 0;

    printf("--- Odbieranie danych ---\n");

    // Czytamy dokładnie N razy
    for (int i = 0; i < N; i++) {
        // Czyścimy bufor przed odczytem
        memset(bufor_odczytu, 0, BUF_SIZE);

        // Próba odczytu
        ssize_t bytes_read = read(fd, bufor_odczytu, BUF_SIZE);

        if (bytes_read > 0) {
            // Parsowanie
            if (sscanf(bufor_odczytu, "%d %d", &pid_child, &liczba) == 2) {
                printf("[Kolektor] Odebrano od PID %d: %d\n", pid_child, liczba);
                suma += liczba;
                odebrane_pakiety++;
            } else {
                printf("[Kolektor] Błąd formatu danych: %s\n", bufor_odczytu);
            }
        } else if (bytes_read == 0) {
            printf("[Kolektor] Koniec danych w potoku przed czasem!\n");
            break;
        } else {
            perror("[Kolektor] Błąd odczytu");
            break;
        }
    }

    close(fd);

    // Czekamy na dzieci
    for(int i=0; i<N; i++) wait(NULL);

    printf("--- Podsumowanie ---\n");
    if (odebrane_pakiety < N) {
        printf("UWAGA: Odebrano tylko %d z %d pakietów (czy któreś dziecko uległo awarii?)\n", odebrane_pakiety, N);
    }
    printf("Suma przesłanych liczb: %d\n", suma);
    
    unlink(FIFO_NAME);
    return 0;
}
tutaj treść:
















tutaj wklej rozwiązania i wiesz jak
zad.1

#!/bin/bash

FIFO_NAME="system_log.fifo"

# Funkcja sprzątająca (SIGINT/EXIT)
cleanup() {
    echo ""
    echo "[SYSTEM] Sprzątanie..."
    if [ -n "$READER_PID" ]; then
        kill "$READER_PID" 2>/dev/null
    fi
    if [ -e "$FIFO_NAME" ]; then
        rm "$FIFO_NAME"
        echo "[SYSTEM] Usunięto $FIFO_NAME"
    fi
    exit 0
}

trap cleanup SIGINT EXIT

# 1. Tworzenie potoku nazwanego
if [ ! -p "$FIFO_NAME" ]; then
    mkfifo "$FIFO_NAME"
    echo "[SYSTEM] Utworzono potok $FIFO_NAME"
fi

# 2. Serwer w tle (czyta z potoku)
(tail -f "$FIFO_NAME" | while read line; do
    echo "[LOG]: $line"
done) &

READER_PID=$!
echo "[SYSTEM] Serwer logów uruchomiony (PID: $READER_PID)"
sleep 1

# 3. Generowanie zdarzeń
echo "[SYSTEM] Generowanie zdarzeń..."

echo "Start systemu" > "$FIFO_NAME"
sleep 1
echo "Użytkownik zalogowany" > "$FIFO_NAME"
sleep 1
echo "Błąd krytyczny: brak kawy" > "$FIFO_NAME"
sleep 1

echo "[SYSTEM] Zakończono."

zad.2


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <string.h>
#include <sys/wait.h>

#define FIFO_NAME "mkfifo"
#define BUF_SIZE 64

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Użycie: %s <liczba_procesow_N>\n", argv[0]);
        return 1;
    }

    int N = atoi(argv[1]);
    
    // Tworzenie potoku
    if (mkfifo(FIFO_NAME, 0666) == -1) {
        // Ignoruj błąd istnienia pliku
    }

    printf("--- Uruchamiam %d procesów potomnych ---\n", N);

    for (int i = 0; i < N; i++) {
        pid_t pid = fork();

        if (pid == 0) {
            // Potomek
            srand(time(NULL) ^ (getpid() << 16));
            int wylosowana = rand() % 100;
            
            char bufor[BUF_SIZE];
            memset(bufor, 0, BUF_SIZE);
            sprintf(bufor, "%d %d", getpid(), wylosowana);

            int fd = open(FIFO_NAME, O_WRONLY);
            if (fd != -1) {
                write(fd, bufor, BUF_SIZE);
                close(fd);
            }
            exit(0);
        }
    }

    // Rodzic (Kolektor)
    int fd = open(FIFO_NAME, O_RDONLY);
    if (fd == -1) {
        perror("Błąd otwarcia potoku");
        return 1;
    }

    int suma = 0;
    char bufor_odczytu[BUF_SIZE];
    int pid_child, liczba;

    printf("--- Odbieranie danych ---\n");
    
    for (int i = 0; i < N; i++) {
        if (read(fd, bufor_odczytu, BUF_SIZE) > 0) {
            sscanf(bufor_odczytu, "%d %d", &pid_child, &liczba);
            printf("[Kolektor] Odebrano od PID %d: %d\n", pid_child, liczba);
            suma += liczba;
        }
    }

    close(fd);
    for(int i=0; i<N; i++) wait(NULL);

    printf("--- Wynik ---\n");
    printf("Suma: %d\n", suma);
    
    unlink(FIFO_NAME);
    return 0;
}

zad.3
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/wait.h>

#define FIFO_A "fifo_A"
#define FIFO_B "fifo_B"

int main() {
    mkfifo(FIFO_A, 0666);
    mkfifo(FIFO_B, 0666);

    pid_t pid = fork();

    if (pid == 0) {
        // --- DZIECKO ---
        // Otwieramy A do odczytu (paruje się z zapisem Rodzica)
        int fd_a = open(FIFO_A, O_RDONLY);
        int fd_b = open(FIFO_B, O_WRONLY);

        char buffer[100];
        read(fd_a, buffer, sizeof(buffer));
        printf("[Dziecko] Odebrano: %s\n", buffer);

        char response[] = "PONG";
        printf("[Dziecko] Wysyłam: %s\n", response);
        write(fd_b, response, strlen(response) + 1);

        close(fd_a);
        close(fd_b);
        exit(0);
    } else {
        // --- RODZIC ---
        // Otwieramy A do zapisu (czeka aż dziecko otworzy odczyt)
        int fd_a = open(FIFO_A, O_WRONLY);
        int fd_b = open(FIFO_B, O_RDONLY);

        char msg[] = "PING";
        printf("[Rodzic] Wysyłam: %s\n", msg);
        write(fd_a, msg, strlen(msg) + 1);

        char buffer[100];
        read(fd_b, buffer, sizeof(buffer));
        printf("[Rodzic] Odebrano: %s\n", buffer);

        close(fd_a);
        close(fd_b);
        wait(NULL);

        unlink(FIFO_A);
        unlink(FIFO_B);
        printf("[Rodzic] Koniec.\n");
    }

    return 0;
}
